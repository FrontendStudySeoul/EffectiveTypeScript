## 타입스크립트와 자바스크립트의 관계
> 타입스크립트는 자바스크립트의 **superset**이다.
> 
> 타입스크립트는 자바스크립트에 **type**을 위한 문법이 추가된 것이다.

### 자바스크립트는
- 동적 타입 언어: 느슨한 타입의 언어로 예상치 못하게 동작할 가능성이 높다.

### 타입스크립트는
![image](https://github.com/FrontendStudySeoul/TypeScript/assets/80238096/5fac524b-50a3-4cfc-9da2-5de94da03f6e)
#### 1. Javascript and More
- 타입스크립트는 자바스크립트에 타입을 추가한 것이다.
- IDE와 통합해서 에러를 빨리 잡을 수 있다.

#### 2. A Result You Can Trust
- 타입스크립트는 자바스크립트로 컴파일된다.
- 하위호환성: 자바스크립트가 실행되는 모든 곳에서 자바스크립트로 변환된다.

#### 3. Safety at Scale
- 타입스크립트는 자바스크립트를 이해한다
- 타입스크립트는 타입 추론을 통해 추가적인 코드 없이 훌륭한 도구를 제공한다.

<br />

## 타입스크립트는 런타임에 오류를 발생시킬 코드를 미리 찾아낸다.
> 정적 타입언어로, 타입 체커가 오류를 발견한다.
- 타입 구문 없이도 오류를 찾아낸다
  - 객체에 해당 속성이 없는 경우에 오류 발생
- 타입 구문을 통해 명시적으로 의도를 들어낼 수 있다.
  - `interface`를 통해 명시적인 타입 지정 

<br />

## 코드 생성과 타입이 관계없음을 이해하기
### 타입스크립트 컴파일러(tsc)의 역할
1. 트랜스파일
   - 최신 타입스크립트, 자바스크립트를 브라우저에서 동작할 수 있도록 하위 버전의 자바스크립트로 변환
2. 타입 체크

#### 컴파일 과정과 타입 체크는 독립적이다.
- 타입스크립트가 자바스크립트로 변환될 때, 코드 내의 타입은 영향을 주지 않는다.
→ 타입 오류가 있는 코드도 컴파일이 가능하다

#### 런타임에는 타입 체크가 불가능하다.
- 타입스크립트가 자바스크립트로 컴파일 되는 과정에서 모든 인터페이스, 타입, 타입 구문은 제거된다.
- 타입 정보를 유지하려면

<br />

## 구조적 타이핑에 익숙해지기
### Duck Typing
> 만약 어떤 새가 오리처럼 걷고, 헤엄치고, 꽥꽥거리는 소리를 낸다면 나는 그 새를 오리라고 부를 것이다.

- 객체가 어떤 타입에 부합하는 변수와 메서드를 가질 경우, 객체를 해당 타입에 속하는 것으로 간주한다.
- 타입스크립트는 매개변수 값이 요구사항을 만족한다면 타입이 무엇인지 신경쓰지 않는다
- 타입이 추가되어도 오류로 인식하지 않는다.

<br />

## any 타입 지양하기
- any 타입 안정성이 없다
- any는 함수 시그니처를 무시한다
- any는 언어 서비스가 적용되지 않는다
- any는 코드 리팩토링 시 버그를 감춘다
- any는 타입 설계를 감춘다
- any는 타입 시스템의 신뢰도를 떨어뜨린다

<br />

## 타입이 값들의 집합이라고 생각하기
> 타입: 할당 가능한 값들의 집합

- `never`: 공집합
- `unit`: 리터럴 타입
  - 하나의 값만 포함할 수 있다
- `union`: 합집합
  - unit을 두 개 이상으로 묶으려면 union 타입을 사용
- `intersection`: 교집합

### Intersection
- `&` 연산자를 사용
- 두 타입의 교집합을 계산
- 인터페이스의 속성이 아닌 값의 집합 (타입 범위)에 적용
- 각 타입 내의 속성을 모두 포함

``` ts
keyof (A&B) = (keyof A) | (keyof B)
keyof (A|B) = (keyof A) & (keyof B)
```

### extends
- 할당 가능한
- ~의 부분집합

``` ts
interface A extends B { // B의 부분집합인 A
}

function getKey<K extends string>(val: any, key: K) { // K는 string의 부분집합
}
```

### 배열과 튜플
`number[]` vs `[number, number]`

- number[]은 [number, number]의 부분집합이 아니기 때문에 할당할 수 없다.
- [number, number]은 number[]의 부분집합이기 때문에 할당할 수 있다.

<br />

## 타입 공간과 값 공간의 심벌 구분하기
> 타입스크립트 코드를 읽으면서 타입인지 값인지 구분하는 방법을 터득해야 한다.

- `type`과 `interface` 같은 키워드는 타입 공간에만 존재한다.
- `“foo”`는 문자열 리터럴이거나, 문자열 리터럴 ‘타입’일 수 있다.
- `typeof`, `this` 그리고 많은 연산자와 키워드들은 타입 공간과 값 공간에서 다른 목적으로 사용될 수 있다.
- `class`나 `enum` 같은 키워드는 타입과 값 두 가지로 사용될 수 있다.

### 속성 접근자 []
- 속성 접근자인 `[]`는 타입으로 쓰일 때에도 동일하게 동작한다. 
- 객체 값의 속성을 확인하는 `obj[’field’]`와 `obj.field`는 ‘값’이 동일하더라도, 타입의 속성은 다를 수 있다. 
- 타입의 속성을 얻을 때는 반드시 첫 번째 방법(`obj[’field’]`)을 사용해야 한다.

### typeof
- 타입의 관점에서 `typeof`는 타입 스크립트 타입을 반환한다. 
  - 반환된 타입을 이용하여 type 구문으로 이름을 붙이거나, 더 큰 타입의 일부로 사용할 수 있다.
- 값의 관점에서 `typeof`는 자바스크립트 런타임의 typeof 연산자다. 
  - 대상 심벌의 런타임 타입을 가리키는 문자열을 반환한다.
